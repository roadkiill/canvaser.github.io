<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvaser - by Roadkiill</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: #111111;
            border-right: 1px solid #222222;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .logo {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 30px;
            letter-spacing: -0.5px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 500;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        /* Tools */
        .tools {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 18px;
        }

        .tool-btn:hover {
            background: #252525;
            border-color: #3a3a3a;
        }

        .tool-btn.active {
            background: #2563eb;
            border-color: #2563eb;
        }

        /* Brush settings */
        .slider-group {
            margin-bottom: 16px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 8px;
            color: #aaa;
        }

        .slider {
            width: 100%;
            height: 4px;
            background: #2a2a2a;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Colors */
        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.active {
            border-color: #fff;
            box-shadow: 0 0 0 2px #000;
        }

        /* Actions */
        .action-btn {
            width: 100%;
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .action-btn:hover {
            background: #252525;
            border-color: #3a3a3a;
        }

        .action-btn.danger:hover {
            background: #dc2626;
            border-color: #dc2626;
        }

        /* Status */
        .status {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid #222;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }

        .status-value {
            color: #fff;
            font-weight: 500;
        }

        .online-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #666;
        }

        .online-dot {
            width: 6px;
            height: 6px;
            background: #22c55e;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Canvas area */
        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        #drawingCanvas {
            background: #ffffff;
            cursor: crosshair;
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.5);
        }

        /* Cursors */
        .canvas-area.brush-cursor #drawingCanvas {
            cursor: crosshair;
        }

        .canvas-area.eraser-cursor #drawingCanvas {
            cursor: cell;
        }

        .canvas-area.pan-cursor #drawingCanvas {
            cursor: grab;
        }

        .canvas-area.panning #drawingCanvas {
            cursor: grabbing;
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 20px;
            z-index: 1000;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #222;
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: #666;
            font-size: 14px;
        }

        /* Boards */
        .boards-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .board-item {
            padding: 10px 12px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .board-item:hover {
            background: #252525;
            border-color: #3a3a3a;
        }

        .board-item.active {
            background: #2563eb;
            border-color: #2563eb;
        }

        .board-name {
            font-weight: 500;
        }

        .board-count {
            font-size: 11px;
            color: #999;
        }

        .board-item.active .board-count {
            color: #bfdbfe;
        }

        /* Vote banner */
        .vote-banner {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            border: 2px solid #ef4444;
            border-radius: 8px;
            padding: 16px 24px;
            z-index: 1000;
            min-width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .vote-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: #ef4444;
        }

        .vote-reason {
            font-size: 13px;
            color: #aaa;
            margin-bottom: 12px;
        }

        .vote-actions {
            display: flex;
            gap: 8px;
        }

        .vote-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .vote-yes {
            background: #ef4444;
            color: white;
        }

        .vote-yes:hover {
            background: #dc2626;
        }

        .vote-no {
            background: #2a2a2a;
            color: white;
        }

        .vote-no:hover {
            background: #3a3a3a;
        }

        .vote-status {
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }

        /* Easter egg */
        .konami-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .konami-content {
            text-align: center;
        }

        .konami-title {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #ff0080, #ff8c00, #40e0d0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbow 3s linear infinite;
        }

        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        .konami-subtitle {
            font-size: 18px;
            color: #888;
            margin-bottom: 30px;
        }

        .konami-close {
            padding: 12px 24px;
            background: #2563eb;
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            font-weight: 500;
        }

        .konami-close:hover {
            background: #1d4ed8;
        }

        /* Chat */
        .chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            background: #111111;
            border: 1px solid #222222;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .chat-header {
            padding: 12px 16px;
            border-bottom: 1px solid #222222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-title {
            font-size: 14px;
            font-weight: 600;
        }

        .chat-toggle {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            transition: color 0.2s;
        }

        .chat-toggle:hover {
            color: #fff;
        }

        .chat-messages {
            height: 300px;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        .chat-message {
            font-size: 13px;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .chat-username {
            font-weight: 600;
            margin-right: 4px;
        }

        .chat-text {
            color: #ccc;
        }

        .chat-system {
            color: #666;
            font-style: italic;
            font-size: 12px;
        }

        .chat-input-container {
            padding: 12px;
            border-top: 1px solid #222222;
        }

        .chat-input {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            padding: 10px 12px;
            color: #fff;
            font-size: 13px;
            font-family: inherit;
            outline: none;
            transition: border-color 0.2s;
        }

        .chat-input:focus {
            border-color: #3a3a3a;
        }

        .chat-input::placeholder {
            color: #666;
        }

        .chat-container.minimized .chat-messages,
        .chat-container.minimized .chat-input-container {
            display: none;
        }

        .chat-container.minimized {
            height: auto;
        }

        /* Command Palette */
        .command-palette {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background: #111111;
            border: 2px solid #2563eb;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            flex-direction: column;
            max-height: 70vh;
        }

        .command-palette.active {
            display: flex;
            animation: commandSlideIn 0.2s ease-out;
        }

        @keyframes commandSlideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .command-input {
            padding: 16px 20px;
            background: #1a1a1a;
            border: none;
            border-bottom: 1px solid #2a2a2a;
            color: #fff;
            font-size: 16px;
            outline: none;
            font-family: 'Courier New', monospace;
        }

        .command-input::placeholder {
            color: #666;
        }

        .command-results {
            overflow-y: auto;
            max-height: 400px;
        }

        .command-results::-webkit-scrollbar {
            width: 6px;
        }

        .command-results::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .command-results::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }

        .command-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background 0.1s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .command-item:hover,
        .command-item.selected {
            background: #2a2a2a;
        }

        .command-name {
            font-size: 14px;
            color: #fff;
            font-weight: 500;
        }

        .command-desc {
            font-size: 12px;
            color: #666;
            margin-left: 12px;
        }

        .command-shortcut {
            font-size: 11px;
            color: #888;
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Layers Panel */
        .layers-panel {
            position: fixed;
            right: 360px;
            bottom: 20px;
            width: 280px;
            background: #111111;
            border: 1px solid #222222;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .layers-header {
            padding: 12px 16px;
            border-bottom: 1px solid #222222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layers-title {
            font-size: 14px;
            font-weight: 600;
        }

        .layers-add {
            background: #2563eb;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .layers-add:hover {
            background: #1d4ed8;
        }

        .layers-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 8px;
        }

        .layer-item {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .layer-item:hover {
            background: #252525;
            border-color: #3a3a3a;
        }

        .layer-item.active {
            border-color: #2563eb;
            background: #1e3a8a;
        }

        .layer-visibility {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .layer-preview {
            width: 40px;
            height: 30px;
            background: white;
            border: 1px solid #2a2a2a;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .layer-info {
            flex: 1;
            min-width: 0;
        }

        .layer-name {
            font-size: 13px;
            font-weight: 500;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-opacity-slider {
            width: 100%;
            height: 3px;
            margin-top: 4px;
        }

        .layer-delete {
            color: #666;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            transition: color 0.2s;
        }

        .layer-delete:hover {
            color: #ef4444;
        }

        /* Minimap */
        .minimap {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: #111111;
            border: 2px solid #222222;
            border-radius: 8px;
            overflow: hidden;
            z-index: 200;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .minimap-viewport {
            position: absolute;
            border: 2px solid #2563eb;
            background: rgba(37, 99, 235, 0.1);
            pointer-events: none;
        }

        .minimap-cursor {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        .minimap-toggle {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.6);
            border: none;
            color: #888;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .minimap-toggle:hover {
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
        }

        .minimap.minimized {
            width: 60px;
            height: 45px;
        }

        .minimap.minimized .minimap-viewport,
        .minimap.minimized .minimap-cursor {
            display: none;
        }

        /* Notification toasts */
        .toast {
            position: fixed;
            bottom: 380px;
            right: 20px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-left: 3px solid #2563eb;
            border-radius: 6px;
            padding: 12px 16px;
            max-width: 300px;
            z-index: 1500;
            animation: toastSlideIn 0.3s ease-out;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .toast.error {
            border-left-color: #ef4444;
        }

        .toast.success {
            border-left-color: #22c55e;
        }

        .toast.warning {
            border-left-color: #f59e0b;
        }

        .toast-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #fff;
        }

        .toast-message {
            font-size: 12px;
            color: #aaa;
        }

        /* Keyboard shortcut hint */
        .shortcut-hint {
            position: fixed;
            bottom: 20px;
            left: 300px;
            background: rgba(17, 17, 17, 0.95);
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 11px;
            color: #888;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .shortcut-hint.visible {
            opacity: 1;
        }

        /* Zoom indicator */
        .zoom-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(17, 17, 17, 0.9);
            border: 1px solid #222;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 12px;
            color: #aaa;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .zoom-indicator.visible {
            opacity: 1;
        }

        /* Live cursors */
        .remote-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            transition: transform 0.1s ease-out;
        }

        .remote-cursor svg {
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .remote-cursor-label {
            position: absolute;
            left: 20px;
            top: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 1px solid #222;
            }

            .app-container {
                flex-direction: column;
            }

            .chat-container {
                width: calc(100% - 40px);
                max-width: 320px;
            }
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loading">
        <div class="spinner"></div>
        <div class="loading-text">Connecting...</div>
    </div>

    <div class="app-container" id="app" style="display: none;">
        <div class="sidebar">
            <div class="logo">Canvas</div>

            <div class="section">
                <div class="section-title">Tools</div>
                <div class="tools">
                    <div class="tool-btn active" id="brushTool" onclick="selectTool('brush')" title="Brush">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                            <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                        </svg>
                    </div>
                    <div class="tool-btn" id="eraserTool" onclick="selectTool('eraser')" title="Eraser">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 20H7L3 16L11 8L17 14L20 11V20Z"/>
                            <path d="M3 16L11 8L17 14"/>
                        </svg>
                    </div>
                    <div class="tool-btn" id="fillTool" onclick="selectTool('fill')" title="Fill Bucket">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 9l-6-6-6 6v12h12V9z"/>
                            <circle cx="18" cy="20" r="2"/>
                        </svg>
                    </div>
                    <div class="tool-btn" id="lineTool" onclick="selectTool('line')" title="Line">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="4" y1="20" x2="20" y2="4"/>
                        </svg>
                    </div>
                    <div class="tool-btn" id="circleTool" onclick="selectTool('circle')" title="Circle">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="8"/>
                        </svg>
                    </div>
                    <div class="tool-btn" id="rectangleTool" onclick="selectTool('rectangle')" title="Rectangle">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="5" y="7" width="14" height="10"/>
                        </svg>
                    </div>
                </div>
                <div class="tools" style="margin-top: 8px;">
                    <div class="tool-btn" id="textTool" onclick="selectTool('text')" title="Text">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="4 7 4 4 20 4 20 7"/>
                            <line x1="9" y1="20" x2="15" y2="20"/>
                            <line x1="12" y1="4" x2="12" y2="20"/>
                        </svg>
                    </div>
                    <div class="tool-btn" id="sprayTool" onclick="selectTool('spray')" title="Spray Paint">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="6" cy="6" r="1" fill="currentColor"/>
                            <circle cx="10" cy="8" r="1" fill="currentColor"/>
                            <circle cx="8" cy="11" r="1" fill="currentColor"/>
                            <circle cx="12" cy="13" r="1" fill="currentColor"/>
                            <circle cx="15" cy="9" r="1" fill="currentColor"/>
                            <path d="M18 3l3 3-12 12-3-3z"/>
                        </svg>
                    </div>
                    <div class="tool-btn" id="reportTool" onclick="selectTool('report')" title="Report Stroke" style="border: 1px solid #ef4444;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="2">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                            <line x1="12" y1="9" x2="12" y2="13"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                    </div>
                    <div class="tool-btn" onclick="undo()" title="Undo">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 7v6h6"/>
                            <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                        </svg>
                    </div>
                    <div class="tool-btn" onclick="redo()" title="Redo">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 7v6h-6"/>
                            <path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/>
                        </svg>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Brush</div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Size</span>
                        <span id="brushSizeValue">5</span>
                    </div>
                    <input type="range" class="slider" id="brushSize" min="1" max="50" value="5">
                </div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Opacity</span>
                        <span id="opacityValue">100</span>
                    </div>
                    <input type="range" class="slider" id="opacity" min="1" max="100" value="100">
                </div>
            </div>

            <div class="section" id="textSection" style="display: none;">
                <div class="section-title">Text</div>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Size</span>
                        <span id="textSizeValue">24</span>
                    </div>
                    <input type="range" class="slider" id="textSize" min="12" max="72" value="24">
                </div>
                <div class="slider-group" style="margin-bottom: 12px;">
                    <select id="fontFamily" class="action-btn" style="margin: 0; padding: 8px;">
                        <option value="Arial">Arial</option>
                        <option value="Comic Sans MS">Comic Sans</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Impact">Impact</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Verdana">Verdana</option>
                    </select>
                </div>
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <button class="action-btn" id="boldBtn" onclick="toggleTextStyle('bold')" style="flex: 1; padding: 8px; font-weight: bold;">B</button>
                    <button class="action-btn" id="italicBtn" onclick="toggleTextStyle('italic')" style="flex: 1; padding: 8px; font-style: italic;">I</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Colors</div>
                <div class="color-grid" id="colorGrid"></div>
            </div>

            <div class="section">
                <div class="section-title">Boards</div>
                <div class="boards-list" id="boardsList"></div>
            </div>

            <div class="section">
                <div class="section-title">Actions</div>
                <button class="action-btn" onclick="downloadCanvas()">Download Canvas</button>
                <button class="action-btn danger" onclick="clearCanvas()">Clear All</button>
            </div>

            <div class="status">
                <div class="online-indicator">
                    <div class="online-dot"></div>
                    <span id="onlineCount">0 online</span>
                </div>
                <div class="status-item">
                    <span>Strokes drawn</span>
                    <span class="status-value" id="strokeCount">0</span>
                </div>
            </div>
        </div>

        <div class="canvas-area brush-cursor" id="canvasArea">
            <canvas id="drawingCanvas" width="1200" height="800"></canvas>
        </div>
    </div>

    <!-- Chat -->
    <div class="chat-container" id="chatContainer" style="display: none;">
        <div class="chat-header">
            <div class="chat-title">Chat</div>
            <button class="chat-toggle" onclick="toggleChat()">‚àí</button>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input-container">
            <input 
                type="text" 
                class="chat-input" 
                id="chatInput" 
                placeholder="Type a message..."
                maxlength="200"
                onkeypress="handleChatKeyPress(event)"
            >
        </div>
    </div>

    <!-- Zoom indicator -->
    <div class="zoom-indicator" id="zoomIndicator">100%</div>

    <!-- Command Palette -->
    <div class="command-palette" id="commandPalette">
        <input type="text" class="command-input" id="commandInput" placeholder="Type a command... (e.g., /help, /goto, /clear)">
        <div class="command-results" id="commandResults"></div>
    </div>

    <!-- Layers Panel -->
    <div class="layers-panel" id="layersPanel">
        <div class="layers-header">
            <div class="layers-title">Layers</div>
            <button class="layers-add" onclick="addLayer()">+</button>
        </div>
        <div class="layers-list" id="layersList"></div>
    </div>

    <!-- Minimap -->
    <div class="minimap" id="minimap">
        <button class="minimap-toggle" onclick="toggleMinimap()">‚àí</button>
        <canvas class="minimap-canvas" id="minimapCanvas" width="200" height="150"></canvas>
        <div class="minimap-viewport" id="minimapViewport"></div>
    </div>

    <!-- Shortcut Hint -->
    <div class="shortcut-hint" id="shortcutHint">Press Ctrl+K to open command palette</div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, push, onChildAdded, remove, set, onValue, onDisconnect, get, update } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const firebaseConfig = {
            apiKey: "AIzaSyBU-dUURuUm0DrCVYR-W-IaF6Qr_SiA5ac",
            authDomain: "draw-app-4f585.firebaseapp.com",
            databaseURL: "https://draw-app-4f585-default-rtdb.firebaseio.com",
            projectId: "draw-app-4f585",
            storageBucket: "draw-app-4f585.firebasestorage.app",
            messagingSenderId: "148544401774",
            appId: "1:148544401774:web:33d711f85dc17361b1d17f",
            measurementId: "G-EPKWC63ZR2"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // ===== COMMAND PALETTE SYSTEM =====
        const COMMANDS = [
            { name: '/help', desc: 'Show all commands', shortcut: 'Ctrl+K' },
            { name: '/clear', desc: 'Clear the canvas', shortcut: 'Ctrl+Shift+C' },
            { name: '/export', desc: 'Download canvas as PNG', shortcut: 'Ctrl+S' },
            { name: '/goto', desc: 'Teleport to user (e.g., /goto user#1234)', shortcut: '' },
            { name: '/follow', desc: 'Follow a user\'s view (e.g., /follow user#1234)', shortcut: '' },
            { name: '/ghost', desc: 'Toggle cursor visibility', shortcut: 'Ctrl+G' },
            { name: '/reset', desc: 'Reset zoom and pan to center', shortcut: 'Ctrl+0' },
            { name: '/layers', desc: 'Toggle layers panel', shortcut: 'Ctrl+L' },
            { name: '/grid', desc: 'Toggle grid overlay', shortcut: 'Ctrl+Shift+G' },
            { name: '/stats', desc: 'Show your drawing stats', shortcut: '' },
            { name: '/users', desc: 'List all online users', shortcut: '' },
            { name: '/theme', desc: 'Change theme (e.g., /theme dark)', shortcut: '' },
            { name: '/undo', desc: 'Undo last action', shortcut: 'Ctrl+Z' },
            { name: '/redo', desc: 'Redo last action', shortcut: 'Ctrl+Y' },
        ];

        let selectedCommandIndex = 0;
        let isFollowing = null;
        let isGhost = false;
        let showGrid = false;

        function showCommandPalette() {
            const palette = document.getElementById('commandPalette');
            palette.classList.add('active');
            document.getElementById('commandInput').value = '';
            document.getElementById('commandInput').focus();
            updateCommandResults('');
        }

        function hideCommandPalette() {
            document.getElementById('commandPalette').classList.remove('active');
        }

        function updateCommandResults(query) {
            const results = document.getElementById('commandResults');
            const filtered = query ? COMMANDS.filter(cmd => 
                cmd.name.includes(query.toLowerCase()) || cmd.desc.toLowerCase().includes(query.toLowerCase())
            ) : COMMANDS;

            if (filtered.length === 0) {
                results.innerHTML = '<div class="command-item"><span class="command-desc">No commands found</span></div>';
                return;
            }

            results.innerHTML = filtered.map((cmd, idx) => `
                <div class="command-item ${idx === selectedCommandIndex ? 'selected' : ''}" onclick="executeCommand('${cmd.name}')">
                    <div>
                        <span class="command-name">${cmd.name}</span>
                        <span class="command-desc">${cmd.desc}</span>
                    </div>
                    ${cmd.shortcut ? `<span class="command-shortcut">${cmd.shortcut}</span>` : ''}
                </div>
            `).join('');
        }

        window.executeCommand = async function(cmdInput) {
            hideCommandPalette();
            const [cmd, ...args] = cmdInput.trim().split(' ');

            switch(cmd) {
                case '/help':
                    showToast('Commands', `Available commands: ${COMMANDS.map(c => c.name).join(', ')}`, 'success');
                    break;

                case '/clear':
                    if (confirm('Clear the entire canvas?')) {
                        clearCanvas();
                    }
                    break;

                case '/export':
                    downloadCanvas();
                    showToast('Export', 'Canvas downloaded!', 'success');
                    break;

                case '/goto':
                    if (args.length === 0) {
                        showToast('Error', 'Usage: /goto username', 'error');
                        return;
                    }
                    await teleportToUser(args.join(' '));
                    break;

                case '/follow':
                    if (args.length === 0) {
                        isFollowing = null;
                        showToast('Follow', 'Stopped following', 'success');
                        return;
                    }
                    isFollowing = args.join(' ');
                    showToast('Follow', `Following ${isFollowing}`, 'success');
                    break;

                case '/ghost':
                    isGhost = !isGhost;
                    showToast('Ghost Mode', isGhost ? 'Cursor hidden' : 'Cursor visible', 'success');
                    break;

                case '/reset':
                    scale = 1;
                    panX = 0;
                    panY = 0;
                    canvasOffsetX = 0;
                    canvasOffsetY = 0;
                    updateCanvasTransform();
                    showToast('View', 'Reset to center', 'success');
                    break;

                case '/layers':
                    const layersPanel = document.getElementById('layersPanel');
                    layersPanel.style.display = layersPanel.style.display === 'none' ? 'flex' : 'none';
                    break;

                case '/grid':
                    showGrid = !showGrid;
                    redrawCanvas();
                    showToast('Grid', showGrid ? 'Grid enabled' : 'Grid disabled', 'success');
                    break;

                case '/stats':
                    const myStrokes = Object.values(allStrokes).filter(s => s.userId === userId).length;
                    showToast('Your Stats', `Strokes: ${myStrokes} | Board: ${currentBoard}`, 'success');
                    break;

                case '/users':
                    const usersSnap = await get(ref(database, 'cursors'));
                    const users = usersSnap.val() || {};
                    const userList = Object.values(users).map(u => u.username).join(', ');
                    showToast('Online Users', userList || 'No one online', 'success');
                    break;

                case '/theme':
                    showToast('Theme', 'Theme switching coming soon!', 'warning');
                    break;

                case '/undo':
                    undo();
                    break;

                case '/redo':
                    redo();
                    break;

                default:
                    showToast('Error', `Unknown command: ${cmd}`, 'error');
            }
        }

        async function teleportToUser(targetUsername) {
            const cursorsSnap = await get(ref(database, 'cursors'));
            const cursors = cursorsSnap.val() || {};
            
            const targetCursor = Object.values(cursors).find(c => c.username === targetUsername);
            
            if (!targetCursor) {
                showToast('Error', `User ${targetUsername} not found`, 'error');
                return;
            }

            // Center view on target user
            const rect = canvas.getBoundingClientRect();
            panX = (rect.width / 2) - (targetCursor.x * scale);
            panY = (rect.height / 2) - (targetCursor.y * scale);
            updateCanvasTransform();
            showToast('Teleport', `Jumped to ${targetUsername}`, 'success');
        }

        function showToast(title, message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <div class="toast-title">${title}</div>
                <div class="toast-message">${message}</div>
            `;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'toastSlideIn 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Command palette input handler
        document.getElementById('commandInput').addEventListener('input', (e) => {
            selectedCommandIndex = 0;
            updateCommandResults(e.target.value);
        });

        document.getElementById('commandInput').addEventListener('keydown', (e) => {
            const results = document.querySelectorAll('.command-item');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedCommandIndex = Math.min(selectedCommandIndex + 1, results.length - 1);
                updateCommandResults(e.target.value);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedCommandIndex = Math.max(selectedCommandIndex - 1, 0);
                updateCommandResults(e.target.value);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                const filtered = e.target.value ? COMMANDS.filter(cmd => 
                    cmd.name.includes(e.target.value.toLowerCase())
                ) : COMMANDS;
                if (filtered[selectedCommandIndex]) {
                    executeCommand(filtered[selectedCommandIndex].name);
                } else {
                    executeCommand(e.target.value);
                }
            } else if (e.key === 'Escape') {
                hideCommandPalette();
            }
        });

        // ===== LAYER SYSTEM =====
        function initLayers() {
            // Create default layer
            const defaultLayer = {
                id: layerIdCounter++,
                name: 'Layer 1',
                visible: true,
                opacity: 100,
                canvas: document.createElement('canvas'),
                strokes: {}
            };
            defaultLayer.canvas.width = canvas.width;
            defaultLayer.canvas.height = canvas.height;
            layers.push(defaultLayer);
            currentLayerId = defaultLayer.id;
            updateLayersUI();
        }

        window.addLayer = function() {
            const newLayer = {
                id: layerIdCounter++,
                name: `Layer ${layers.length + 1}`,
                visible: true,
                opacity: 100,
                canvas: document.createElement('canvas'),
                strokes: {}
            };
            newLayer.canvas.width = canvas.width;
            newLayer.canvas.height = canvas.height;
            layers.push(newLayer);
            currentLayerId = newLayer.id;
            updateLayersUI();
            redrawCanvas();
            showToast('Layers', `Added ${newLayer.name}`, 'success');
        }

        function deleteLayer(layerId) {
            if (layers.length === 1) {
                showToast('Error', 'Cannot delete the last layer', 'error');
                return;
            }
            
            layers = layers.filter(l => l.id !== layerId);
            if (currentLayerId === layerId) {
                currentLayerId = layers[layers.length - 1].id;
            }
            updateLayersUI();
            redrawCanvas();
        }

        function toggleLayerVisibility(layerId) {
            const layer = layers.find(l => l.id === layerId);
            if (layer) {
                layer.visible = !layer.visible;
                updateLayersUI();
                redrawCanvas();
            }
        }

        function selectLayer(layerId) {
            currentLayerId = layerId;
            updateLayersUI();
        }

        function updateLayerOpacity(layerId, opacity) {
            const layer = layers.find(l => l.id === layerId);
            if (layer) {
                layer.opacity = opacity;
                redrawCanvas();
            }
        }

        function updateLayersUI() {
            const list = document.getElementById('layersList');
            list.innerHTML = layers.slice().reverse().map(layer => `
                <div class="layer-item ${layer.id === currentLayerId ? 'active' : ''}" onclick="selectLayer(${layer.id})">
                    <div class="layer-visibility" onclick="event.stopPropagation(); toggleLayerVisibility(${layer.id})">
                        ${layer.visible ? 'üëÅÔ∏è' : 'üö´'}
                    </div>
                    <div class="layer-preview"></div>
                    <div class="layer-info">
                        <div class="layer-name">${layer.name}</div>
                        <input type="range" class="slider layer-opacity-slider" min="0" max="100" value="${layer.opacity}" 
                               onchange="updateLayerOpacity(${layer.id}, this.value)" onclick="event.stopPropagation()">
                    </div>
                    <div class="layer-delete" onclick="event.stopPropagation(); deleteLayer(${layer.id})">√ó</div>
                </div>
            `).join('');
        }

        function getCurrentLayer() {
            return layers.find(l => l.id === currentLayerId);
        }

        // ===== KEYBOARD SHORTCUTS =====
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in inputs
            if (e.target.tagName === 'INPUT' && e.target.id !== 'commandInput') return;

            // Ctrl/Cmd + K: Command palette
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                showCommandPalette();
            }

            // Ctrl/Cmd + S: Export
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                downloadCanvas();
                showToast('Export', 'Canvas downloaded!', 'success');
            }

            // Ctrl/Cmd + Z: Undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }

            // Ctrl/Cmd + Y or Ctrl + Shift + Z: Redo
            if (((e.ctrlKey || e.metaKey) && e.key === 'y') || 
                ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z')) {
                e.preventDefault();
                redo();
            }

            // Ctrl/Cmd + 0: Reset view
            if ((e.ctrlKey || e.metaKey) && e.key === '0') {
                e.preventDefault();
                executeCommand('/reset');
            }

            // Ctrl/Cmd + G: Ghost mode
            if ((e.ctrlKey || e.metaKey) && e.key === 'g') {
                e.preventDefault();
                executeCommand('/ghost');
            }

            // Ctrl/Cmd + L: Toggle layers
            if ((e.ctrlKey || e.metaKey) && e.key === 'l') {
                e.preventDefault();
                executeCommand('/layers');
            }

            // Tool shortcuts (B, E, T, F, etc.)
            if (!e.ctrlKey && !e.metaKey && !e.altKey) {
                switch(e.key.toLowerCase()) {
                    case 'b': selectTool('brush'); break;
                    case 'e': selectTool('eraser'); break;
                    case 't': selectTool('text'); break;
                    case 'f': selectTool('fill'); break;
                    case 'l': selectTool('line'); break;
                    case 'c': selectTool('circle'); break;
                    case 'r': selectTool('rectangle'); break;
                    case 's': selectTool('spray'); break;
                }
            }

            // Escape: Close command palette
            if (e.key === 'Escape') {
                hideCommandPalette();
            }
        });

        // Show shortcut hint on load
        setTimeout(() => {
            const hint = document.getElementById('shortcutHint');
            hint.classList.add('visible');
            setTimeout(() => hint.classList.remove('visible'), 3000);
        }, 2000);

        // ===== MINIMAP SYSTEM =====
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimapViewport = document.getElementById('minimapViewport');

        function updateMinimap() {
            // Draw scaled-down version of main canvas
            minimapCtx.fillStyle = '#0a0a0a';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            const scaleX = minimapCanvas.width / canvas.width;
            const scaleY = minimapCanvas.height / canvas.height;
            minimapCtx.drawImage(canvas, 0, 0, minimapCanvas.width, minimapCanvas.height);

            // Draw other users' cursors on minimap
            Object.keys(remoteCursors).forEach(cursorId => {
                const cursor = remoteCursors[cursorId];
                if (cursor) {
                    const x = cursor.x * scaleX;
                    const y = cursor.y * scaleY;
                    
                    const dot = document.createElement('div');
                    dot.className = 'minimap-cursor';
                    dot.style.left = x + 'px';
                    dot.style.top = y + 'px';
                    dot.style.background = cursor.color;
                    
                    // Remove old cursor dot
                    const oldDot = document.getElementById(`minimap-cursor-${cursorId}`);
                    if (oldDot) oldDot.remove();
                    
                    dot.id = `minimap-cursor-${cursorId}`;
                    document.getElementById('minimap').appendChild(dot);
                }
            });

            // Update viewport rectangle
            const rect = canvas.getBoundingClientRect();
            const viewportWidth = (rect.width / scale) * scaleX;
            const viewportHeight = (rect.height / scale) * scaleY;
            const viewportX = (-panX / scale) * scaleX;
            const viewportY = (-panY / scale) * scaleY;

            minimapViewport.style.width = viewportWidth + 'px';
            minimapViewport.style.height = viewportHeight + 'px';
            minimapViewport.style.left = viewportX + 'px';
            minimapViewport.style.top = viewportY + 'px';
        }

        window.toggleMinimap = function() {
            const minimap = document.getElementById('minimap');
            minimap.classList.toggle('minimized');
            const btn = minimap.querySelector('.minimap-toggle');
            btn.textContent = minimap.classList.contains('minimized') ? '+' : '‚àí';
        }

        // Update minimap periodically
        setInterval(updateMinimap, 500);

        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');

        let currentBoard = 'board1';
        let strokesRef = ref(database, `boards/${currentBoard}/strokes`);
        let chatRef = ref(database, 'chat');

        let isDrawing = false;
        let currentStroke = [];
        let currentTool = 'brush';
        let currentColor = '#000000';
        let brushSize = 5;
        let opacity = 100;
        let userId = localStorage.getItem('canvasUserId') || 'user_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('canvasUserId', userId);
        
        // Generate username and color
        let username = localStorage.getItem('canvasUsername') || `user#${Math.floor(Math.random() * 9999)}`;
        localStorage.setItem('canvasUsername', username);
        
        const USERNAME_COLORS = [
            '#EF4444', '#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', 
            '#EC4899', '#06B6D4', '#6366F1', '#A855F7', '#F43F5E',
            '#14B8A6', '#F97316', '#84CC16', '#0EA5E9', '#D946EF'
        ];
        
        let userColor = localStorage.getItem('canvasUserColor');
        if (!userColor) {
            userColor = USERNAME_COLORS[Math.floor(Math.random() * USERNAME_COLORS.length)];
            localStorage.setItem('canvasUserColor', userColor);
        }
        
        let strokeCount = 0;
        let undoStack = [];
        let redoStack = [];
        let allStrokes = {};
        let shapeStart = null;
        let tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        let tempCtx = tempCanvas.getContext('2d');

        // Text tool settings
        let textSize = 24;
        let fontFamily = 'Arial';
        let isBold = false;
        let isItalic = false;

        // Layer system
        let layers = [];
        let currentLayerId = null;
        let layerIdCounter = 0;

        // Infinite canvas
        const CANVAS_VIRTUAL_SIZE = 10000; // Virtual canvas is 10000x10000
        let canvasOffsetX = 0;
        let canvasOffsetY = 0;

        // Live cursors
        let remoteCursors = {};
        let cursorUpdateThrottle = null;

        // Canvas pan and zoom
        let scale = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // Profanity filter
        const CURSE_WORDS = [
            'fuck', 'shit', 'damn', 'ass', 'bitch', 'bastard', 'crap', 'piss',
            'dick', 'cock', 'pussy', 'cunt', 'fag', 'nigger', 'nigga', 'whore',
            'slut', 'retard', 'motherfucker', 'asshole', 'douche', 'twat'
        ];

        function censorMessage(message) {
            let censored = message;
            CURSE_WORDS.forEach(word => {
                const regex = new RegExp(word, 'gi');
                censored = censored.replace(regex, '*'.repeat(word.length));
            });
            return censored;
        }

        // Chat functions
        window.toggleChat = function() {
            const container = document.getElementById('chatContainer');
            container.classList.toggle('minimized');
            const toggle = container.querySelector('.chat-toggle');
            toggle.textContent = container.classList.contains('minimized') ? '+' : '‚àí';
        }

        window.handleChatKeyPress = function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        }

        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;

            // Check if it's a command
            if (message.startsWith('/')) {
                executeCommand(message);
                input.value = '';
                return;
            }

            const censoredMessage = censorMessage(message);

            push(chatRef, {
                userId: userId,
                username: username,
                color: userColor,
                message: censoredMessage,
                timestamp: Date.now()
            });

            input.value = '';
        }

        function addChatMessage(data) {
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            
            if (data.system) {
                messageDiv.classList.add('chat-system');
                messageDiv.textContent = data.message;
            } else {
                const usernameSpan = document.createElement('span');
                usernameSpan.className = 'chat-username';
                usernameSpan.style.color = data.color || '#fff';
                usernameSpan.textContent = data.username + ':';
                
                const textSpan = document.createElement('span');
                textSpan.className = 'chat-text';
                textSpan.textContent = data.message;
                
                messageDiv.appendChild(usernameSpan);
                messageDiv.appendChild(textSpan);
            }
            
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            // Limit messages to last 100
            while (messagesDiv.children.length > 100) {
                messagesDiv.removeChild(messagesDiv.firstChild);
            }
        }

        // Listen for chat messages
        onChildAdded(chatRef, (snapshot) => {
            const data = snapshot.val();
            addChatMessage(data);
        });

        // Zoom and pan functions
        function updateCanvasTransform() {
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        }

        function showZoomIndicator() {
            const indicator = document.getElementById('zoomIndicator');
            indicator.textContent = Math.round(scale * 100) + '%';
            indicator.classList.add('visible');
            
            clearTimeout(window.zoomTimeout);
            window.zoomTimeout = setTimeout(() => {
                indicator.classList.remove('visible');
            }, 1000);
        }

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(5, scale * delta));
            
            // Zoom towards mouse position
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            panX = mouseX - (mouseX - panX) * (newScale / scale);
            panY = mouseY - (mouseY - panY) * (newScale / scale);
            
            scale = newScale;
            updateCanvasTransform();
            showZoomIndicator();
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1) { // Middle mouse button
                e.preventDefault();
                isPanning = true;
                panStart = { x: e.clientX - panX, y: e.clientY - panY };
                document.getElementById('canvasArea').classList.add('panning');
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isPanning) {
                panX = e.clientX - panStart.x;
                panY = e.clientY - panStart.y;
                updateCanvasTransform();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 1) {
                isPanning = false;
                document.getElementById('canvasArea').classList.remove('panning');
            }
        });

        // Prevent middle click from opening links/scrolling
        canvas.addEventListener('auxclick', (e) => {
            if (e.button === 1) {
                e.preventDefault();
            }
        });

        // Konami code easter egg
        let konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
        let konamiIndex = 0;

        document.addEventListener('keydown', (e) => {
            if (e.key === konamiCode[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiCode.length) {
                    showKonamiEasterEgg();
                    konamiIndex = 0;
                }
            } else {
                konamiIndex = 0;
            }
        });

        function showKonamiEasterEgg() {
            const overlay = document.createElement('div');
            overlay.className = 'konami-overlay';
            overlay.innerHTML = `
                <div class="konami-content">
                    <div class="konami-title">DISCO MODE ACTIVATED!</div>
                    <div class="konami-subtitle">You found the secret! Press ESC to continue.</div>
                    <button class="konami-close" onclick="this.parentElement.parentElement.remove()">Close</button>
                </div>
            `;
            document.body.appendChild(overlay);

            let hue = 0;
            const interval = setInterval(() => {
                document.body.style.background = `hsl(${hue}, 70%, 10%)`;
                hue = (hue + 1) % 360;
            }, 50);

            const close = () => {
                clearInterval(interval);
                document.body.style.background = '#0a0a0a';
                overlay.remove();
                document.removeEventListener('keydown', escHandler);
            };

            const escHandler = (e) => {
                if (e.key === 'Escape') close();
            };

            document.addEventListener('keydown', escHandler);
            overlay.querySelector('.konami-close').onclick = close;
        }

        async function checkBan() {
            const banRef = ref(database, `bans/${userId}`);
            const snapshot = await get(banRef);
            if (snapshot.exists()) {
                const banData = snapshot.val();
                const now = Date.now();
                if (banData.until > now) {
                    const minutesLeft = Math.ceil((banData.until - now) / 60000);
                    alert(`You are temporarily banned for ${minutesLeft} minutes. Reason: ${banData.reason}`);
                    window.location.href = 'about:blank';
                    return true;
                }
            }
            return false;
        }

        const COLORS = [
            '#000000', '#FFFFFF', '#EF4444', '#F59E0B', '#10B981', '#3B82F6',
            '#8B5CF6', '#EC4899', '#64748B', '#DC2626', '#EA580C', '#84CC16',
            '#06B6D4', '#6366F1', '#A855F7', '#F43F5E', '#71717A', '#78716C'
        ];

        function initColors() {
            const grid = document.getElementById('colorGrid');
            COLORS.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch' + (index === 0 ? ' active' : '');
                swatch.style.background = color;
                swatch.onclick = () => selectColor(color, swatch);
                grid.appendChild(swatch);
            });
        }

        function selectColor(color, swatch) {
            currentColor = color;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            swatch.classList.add('active');
        }

        function initBoards() {
            const boardsList = document.getElementById('boardsList');
            for (let i = 1; i <= 5; i++) {
                const boardDiv = document.createElement('div');
                boardDiv.className = 'board-item' + (i === 1 ? ' active' : '');
                boardDiv.innerHTML = `
                    <span class="board-name">Board ${i}</span>
                    <span class="board-count" id="board${i}Count">0</span>
                `;
                boardDiv.onclick = () => switchBoard(`board${i}`, boardDiv);
                boardsList.appendChild(boardDiv);
            }
        }

        function switchBoard(boardId, element) {
            currentBoard = boardId;
            document.querySelectorAll('.board-item').forEach(b => b.classList.remove('active'));
            element.classList.add('active');
            
            strokesRef = ref(database, `boards/${currentBoard}/strokes`);
            allStrokes = {};
            undoStack = [];
            redoStack = [];
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            listenForUpdates();
        }

        window.selectTool = function(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            if (document.getElementById(tool + 'Tool')) {
                document.getElementById(tool + 'Tool').classList.add('active');
            }
            
            const canvasArea = document.getElementById('canvasArea');
            canvasArea.className = 'canvas-area ' + tool + '-cursor';

            // Show/hide text section
            const textSection = document.getElementById('textSection');
            if (tool === 'text') {
                textSection.style.display = 'block';
            } else {
                textSection.style.display = 'none';
            }
        }

        // Text tool functions
        window.toggleTextStyle = function(style) {
            if (style === 'bold') {
                isBold = !isBold;
                document.getElementById('boldBtn').style.background = isBold ? '#2563eb' : '#1a1a1a';
            } else if (style === 'italic') {
                isItalic = !isItalic;
                document.getElementById('italicBtn').style.background = isItalic ? '#2563eb' : '#1a1a1a';
            }
        }

        document.getElementById('textSize').addEventListener('input', (e) => {
            textSize = parseInt(e.target.value);
            document.getElementById('textSizeValue').textContent = textSize;
        });

        document.getElementById('fontFamily').addEventListener('change', (e) => {
            fontFamily = e.target.value;
        });

        function addText(x, y) {
            const text = prompt('Enter text:');
            if (!text || text.trim() === '') return;

            const textData = {
                type: 'text',
                text: text.trim(),
                x: x,
                y: y,
                color: currentColor,
                size: textSize,
                font: fontFamily,
                bold: isBold,
                italic: isItalic,
                userId: userId,
                layerId: currentLayerId,
                timestamp: Date.now()
            };

            push(strokesRef, textData);
            undoStack.push(textData);
            redoStack = [];
        }

        function drawText(data, context) {
            let fontStyle = '';
            if (data.italic) fontStyle += 'italic ';
            if (data.bold) fontStyle += 'bold ';
            
            context.font = `${fontStyle}${data.size}px ${data.font}`;
            context.fillStyle = data.color;
            context.textBaseline = 'top';
            context.fillText(data.text, data.x, data.y);
        }

        // Live cursor functions
        function updateCursorPosition(x, y) {
            if (isGhost || cursorUpdateThrottle) return;
            
            const cursorsRef = ref(database, `cursors/${userId}`);
            set(cursorsRef, {
                x: x,
                y: y,
                username: username,
                color: userColor,
                timestamp: Date.now()
            });

            cursorUpdateThrottle = setTimeout(() => {
                cursorUpdateThrottle = null;
            }, 50); // Throttle to 20 updates per second
        }

        function createRemoteCursor(cursorData, cursorId) {
            const cursor = document.createElement('div');
            cursor.className = 'remote-cursor';
            cursor.id = `cursor-${cursorId}`;
            cursor.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="${cursorData.color}" stroke="white" stroke-width="1">
                    <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
                <div class="remote-cursor-label" style="color: ${cursorData.color}">${cursorData.username}</div>
            `;
            document.getElementById('canvasArea').appendChild(cursor);
            return cursor;
        }

        function updateRemoteCursor(cursorId, cursorData) {
            let cursor = document.getElementById(`cursor-${cursorId}`);
            if (!cursor) {
                cursor = createRemoteCursor(cursorData, cursorId);
            }

            const canvasRect = canvas.getBoundingClientRect();
            const screenX = canvasRect.left + (cursorData.x * canvasRect.width / canvas.width);
            const screenY = canvasRect.top + (cursorData.y * canvasRect.height / canvas.height);

            cursor.style.left = screenX + 'px';
            cursor.style.top = screenY + 'px';
            cursor.style.transform = 'translate(0, 0)';

            // Remove cursor if too old (user left)
            if (Date.now() - cursorData.timestamp > 5000) {
                cursor.remove();
                delete remoteCursors[cursorId];
            }
        }

        // Track mouse movement for live cursors
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            updateCursorPosition(x, y);
        });

        // Listen for other users' cursors
        onValue(ref(database, 'cursors'), (snapshot) => {
            const cursors = snapshot.val() || {};
            
            Object.keys(cursors).forEach(cursorId => {
                if (cursorId !== userId) {
                    updateRemoteCursor(cursorId, cursors[cursorId]);
                    remoteCursors[cursorId] = cursors[cursorId];

                    // Follow mode
                    if (isFollowing && cursors[cursorId].username === isFollowing) {
                        const rect = canvas.getBoundingClientRect();
                        panX = (rect.width / 2) - (cursors[cursorId].x * scale);
                        panY = (rect.height / 2) - (cursors[cursorId].y * scale);
                        updateCanvasTransform();
                    }
                }
            });

            // Remove cursors that are no longer in the database
            Object.keys(remoteCursors).forEach(cursorId => {
                if (!cursors[cursorId] && cursorId !== userId) {
                    const cursor = document.getElementById(`cursor-${cursorId}`);
                    if (cursor) cursor.remove();
                    delete remoteCursors[cursorId];
                }
            });
        });

        // Clean up cursor on disconnect
        const cursorRef = ref(database, `cursors/${userId}`);
        onDisconnect(cursorRef).remove();

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        document.getElementById('opacity').addEventListener('input', (e) => {
            opacity = parseInt(e.target.value);
            document.getElementById('opacityValue').textContent = opacity;
        });

        window.undo = function() {
            if (undoStack.length === 0) return;
            
            const lastStroke = undoStack.pop();
            redoStack.push(lastStroke);
            
            const strokeToRemove = Object.keys(allStrokes).find(key => 
                allStrokes[key].userId === userId && 
                allStrokes[key].timestamp === lastStroke.timestamp
            );
            
            if (strokeToRemove) {
                remove(ref(database, `boards/${currentBoard}/strokes/${strokeToRemove}`));
            }
        }

        window.redo = function() {
            if (redoStack.length === 0) return;
            
            const stroke = redoStack.pop();
            undoStack.push(stroke);
            
            push(strokesRef, stroke);
        }

        function startDrawing(e) {
            if (isPanning) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (currentTool === 'text') {
                addText(x, y);
                return;
            }

            if (currentTool === 'report') {
                handleReport(x, y);
                return;
            }

            if (currentTool === 'fill') {
                floodFill(x, y);
                return;
            }

            if (['line', 'circle', 'rectangle'].includes(currentTool)) {
                isDrawing = true;
                shapeStart = {x, y};
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                return;
            }

            isDrawing = true;
            currentStroke = [{x, y}];
        }

        function draw(e) {
            if (!isDrawing || isPanning) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (['line', 'circle', 'rectangle'].includes(currentTool)) {
                drawShapePreview(x, y);
                return;
            }

            currentStroke.push({x, y});

            if (currentTool === 'spray') {
                drawSpray(x, y);
            } else {
                drawStroke(currentStroke, currentColor, brushSize, opacity, currentTool, ctx);
            }
        }

        function stopDrawing() {
            if (!isDrawing || currentStroke.length === 0 && !shapeStart) return;
            
            isDrawing = false;

            let strokeData;

            if (['line', 'circle', 'rectangle'].includes(currentTool) && shapeStart) {
                const rect = canvas.getBoundingClientRect();
                const lastPos = tempCanvas.lastMousePos || shapeStart;
                
                strokeData = {
                    type: currentTool,
                    start: shapeStart,
                    end: lastPos,
                    color: currentColor,
                    size: brushSize,
                    opacity: opacity,
                    userId: userId,
                    layerId: currentLayerId,
                    timestamp: Date.now()
                };
                
                shapeStart = null;
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            } else if (currentStroke.length > 0) {
                strokeData = {
                    points: currentStroke,
                    color: currentColor,
                    size: brushSize,
                    opacity: opacity,
                    tool: currentTool,
                    userId: userId,
                    layerId: currentLayerId,
                    timestamp: Date.now()
                };
            }

            if (strokeData) {
                push(strokesRef, strokeData);
                undoStack.push(strokeData);
                redoStack = [];
                currentStroke = [];
            }
        }

        function drawShapePreview(x, y) {
            tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            tempCanvas.lastMousePos = {x, y};
            
            tempCtx.lineCap = 'round';
            tempCtx.lineJoin = 'round';
            tempCtx.lineWidth = brushSize;
            const rgb = hexToRgb(currentColor);
            tempCtx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity / 100})`;

            if (currentTool === 'line') {
                tempCtx.beginPath();
                tempCtx.moveTo(shapeStart.x, shapeStart.y);
                tempCtx.lineTo(x, y);
                tempCtx.stroke();
            } else if (currentTool === 'circle') {
                const radius = Math.sqrt(Math.pow(x - shapeStart.x, 2) + Math.pow(y - shapeStart.y, 2));
                tempCtx.beginPath();
                tempCtx.arc(shapeStart.x, shapeStart.y, radius, 0, 2 * Math.PI);
                tempCtx.stroke();
            } else if (currentTool === 'rectangle') {
                const width = x - shapeStart.x;
                const height = y - shapeStart.y;
                tempCtx.strokeRect(shapeStart.x, shapeStart.y, width, height);
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            redrawCanvas();
            ctx.drawImage(tempCanvas, 0, 0);
        }

        function drawSpray(x, y) {
            const density = 20;
            const radius = brushSize * 2;
            
            for (let i = 0; i < density; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * radius;
                const sprayX = x + Math.cos(angle) * distance;
                const sprayY = y + Math.sin(angle) * distance;
                
                ctx.fillStyle = currentColor;
                ctx.globalAlpha = opacity / 100;
                ctx.fillRect(sprayX, sprayY, 1, 1);
                ctx.globalAlpha = 1;
            }
        }

        function floodFill(startX, startY) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const startPos = (Math.floor(startY) * canvas.width + Math.floor(startX)) * 4;
            const startR = pixels[startPos];
            const startG = pixels[startPos + 1];
            const startB = pixels[startPos + 2];

            const rgb = hexToRgb(currentColor);
            const fillR = rgb.r;
            const fillG = rgb.g;
            const fillB = rgb.b;

            if (startR === fillR && startG === fillG && startB === fillB) return;

            const stack = [{x: Math.floor(startX), y: Math.floor(startY)}];
            const visited = new Set();

            while (stack.length > 0) {
                const {x, y} = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key)) continue;
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                
                const pos = (y * canvas.width + x) * 4;
                const r = pixels[pos];
                const g = pixels[pos + 1];
                const b = pixels[pos + 2];

                if (r !== startR || g !== startG || b !== startB) continue;

                visited.add(key);
                pixels[pos] = fillR;
                pixels[pos + 1] = fillG;
                pixels[pos + 2] = fillB;

                stack.push({x: x + 1, y});
                stack.push({x: x - 1, y});
                stack.push({x, y: y + 1});
                stack.push({x, y: y - 1});
            }

            ctx.putImageData(imageData, 0, 0);

            const fillData = {
                type: 'fill',
                x: startX,
                y: startY,
                color: currentColor,
                userId: userId,
                layerId: currentLayerId,
                timestamp: Date.now()
            };

            push(strokesRef, fillData);
        }

        function drawStroke(points, color, size, opacity, tool, context) {
            if (points.length < 2) return;

            context.lineCap = 'round';
            context.lineJoin = 'round';
            context.lineWidth = size;
            
            if (tool === 'eraser') {
                context.globalCompositeOperation = 'destination-out';
                context.strokeStyle = 'rgba(0,0,0,1)';
            } else {
                context.globalCompositeOperation = 'source-over';
                const rgb = hexToRgb(color);
                context.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity / 100})`;
            }

            context.beginPath();
            context.moveTo(points[0].x, points[0].y);

            for (let i = 1; i < points.length; i++) {
                context.lineTo(points[i].x, points[i].y);
            }

            context.stroke();
        }

        function drawShape(data, context) {
            context.lineCap = 'round';
            context.lineJoin = 'round';
            context.lineWidth = data.size;
            const rgb = hexToRgb(data.color);
            context.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${data.opacity / 100})`;

            if (data.type === 'line') {
                context.beginPath();
                context.moveTo(data.start.x, data.start.y);
                context.lineTo(data.end.x, data.end.y);
                context.stroke();
            } else if (data.type === 'circle') {
                const radius = Math.sqrt(Math.pow(data.end.x - data.start.x, 2) + Math.pow(data.end.y - data.start.y, 2));
                context.beginPath();
                context.arc(data.start.x, data.start.y, radius, 0, 2 * Math.PI);
                context.stroke();
            } else if (data.type === 'rectangle') {
                const width = data.end.x - data.start.x;
                const height = data.end.y - data.start.y;
                context.strokeRect(data.start.x, data.start.y, width, height);
            }
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r: 0, g: 0, b: 0};
        }

        function redrawCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid if enabled
            if (showGrid) {
                ctx.strokeStyle = '#e5e5e5';
                ctx.lineWidth = 1;
                const gridSize = 50;
                
                for (let x = 0; x < canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                for (let y = 0; y < canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }

            // Draw all layers
            layers.forEach(layer => {
                if (!layer.visible) return;
                
                ctx.globalAlpha = layer.opacity / 100;
                
                // Draw all strokes for this layer
                Object.values(allStrokes).forEach(stroke => {
                    if (stroke.layerId === layer.id || (!stroke.layerId && layer.id === 0)) {
                        if (stroke.type === 'fill') {
                            // Skip fill operations in redraw
                        } else if (stroke.type === 'text') {
                            drawText(stroke, ctx);
                        } else if (stroke.type && ['line', 'circle', 'rectangle'].includes(stroke.type)) {
                            drawShape(stroke, ctx);
                        } else if (stroke.points) {
                            drawStroke(stroke.points, stroke.color, stroke.size, stroke.opacity, stroke.tool, ctx);
                        }
                    }
                });
                
                ctx.globalAlpha = 1;
            });
        }

        function handleReport(x, y) {
            const clickedStroke = findStrokeAtPosition(x, y);
            if (!clickedStroke) {
                alert('No stroke found at this position. Try clicking directly on a stroke.');
                return;
            }

            if (clickedStroke.userId === userId) {
                alert('You cannot report your own strokes.');
                return;
            }

            const reason = prompt('Why are you reporting this stroke?\n(e.g., inappropriate content, spam, etc.)');
            if (!reason || reason.trim() === '') return;

            const reportData = {
                strokeId: clickedStroke.id,
                reportedUser: clickedStroke.userId,
                reporter: userId,
                reason: reason.trim(),
                timestamp: Date.now(),
                votes: {
                    [userId]: true
                }
            };

            const reportRef = push(ref(database, 'reports'), reportData);
            
            set(ref(database, `activeVote`), {
                reportId: reportRef.key,
                reportedUser: clickedStroke.userId,
                reason: reason.trim(),
                timestamp: Date.now()
            });
        }

        function findStrokeAtPosition(x, y) {
            const tolerance = 10;
            
            for (const [id, stroke] of Object.entries(allStrokes)) {
                if (stroke.points) {
                    for (const point of stroke.points) {
                        const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                        if (distance <= tolerance + stroke.size / 2) {
                            return { ...stroke, id };
                        }
                    }
                } else if (stroke.type && stroke.start && stroke.end) {
                    const dist = pointToLineDistance(x, y, stroke.start.x, stroke.start.y, stroke.end.x, stroke.end.y);
                    if (dist <= tolerance + stroke.size / 2) {
                        return { ...stroke, id };
                    }
                }
            }
            return null;
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2));
            
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (len * len)));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            
            return Math.sqrt(Math.pow(px - projX, 2) + Math.pow(py - projY, 2));
        }

        let currentVoteId = null;

        function showVoteBanner(reportData, reportId) {
            if (currentVoteId === reportId) return;
            currentVoteId = reportId;

            const existing = document.querySelector('.vote-banner');
            if (existing) existing.remove();

            const banner = document.createElement('div');
            banner.className = 'vote-banner';
            banner.innerHTML = `
                <div class="vote-header">Vote to kick user?</div>
                <div class="vote-reason">Reason: ${reportData.reason}</div>
                <div class="vote-actions">
                    <button class="vote-btn vote-yes" onclick="castVote('${reportId}', true)">Yes, kick them</button>
                    <button class="vote-btn vote-no" onclick="castVote('${reportId}', false)">No</button>
                </div>
                <div class="vote-status" id="voteStatus">Waiting for votes...</div>
            `;
            document.body.appendChild(banner);

            setTimeout(() => {
                banner.remove();
                currentVoteId = null;
            }, 30000);
        }

        window.castVote = async function(reportId, vote) {
            const reportRef = ref(database, `reports/${reportId}`);
            const snapshot = await get(reportRef);
            
            if (!snapshot.exists()) return;

            const reportData = snapshot.val();
            const votes = reportData.votes || {};
            votes[userId] = vote;

            await update(reportRef, { votes });

            const banner = document.querySelector('.vote-banner');
            if (banner) {
                banner.querySelector('#voteStatus').textContent = 'Vote recorded!';
            }
        }

        onValue(ref(database, 'activeVote'), async (snapshot) => {
            if (!snapshot.exists()) return;

            const voteData = snapshot.val();
            if (voteData.reportedUser === userId) return;

            showVoteBanner(voteData, voteData.reportId);

            const reportRef = ref(database, `reports/${voteData.reportId}`);
            const reportSnap = await get(reportRef);
            
            if (!reportSnap.exists()) return;

            const reportData = reportSnap.val();
            const votes = reportData.votes || {};
            const yesVotes = Object.values(votes).filter(v => v === true).length;
            const totalVotes = Object.values(votes).length;

            const usersSnap = await get(ref(database, 'users'));
            const onlineCount = usersSnap.exists() ? Object.keys(usersSnap.val()).length : 1;

            const threshold = Math.max(2, Math.ceil(onlineCount * 0.4));

            if (yesVotes >= threshold) {
                const banUntil = Date.now() + (2 * 60 * 60 * 1000);
                await set(ref(database, `bans/${voteData.reportedUser}`), {
                    until: banUntil,
                    reason: voteData.reason,
                    timestamp: Date.now()
                });

                await remove(ref(database, 'activeVote'));

                const banner = document.querySelector('.vote-banner');
                if (banner) {
                    banner.querySelector('#voteStatus').textContent = 'User has been kicked!';
                    setTimeout(() => banner.remove(), 3000);
                }
            }
        });

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

        function listenForUpdates() {
            strokeCount = 0;
            allStrokes = {};

            onChildAdded(strokesRef, (snapshot) => {
                const stroke = snapshot.val();
                allStrokes[snapshot.key] = stroke;

                if (stroke.type === 'fill') {
                    // Handle fill
                } else if (stroke.type === 'text') {
                    drawText(stroke, ctx);
                } else if (stroke.type && ['line', 'circle', 'rectangle'].includes(stroke.type)) {
                    drawShape(stroke, ctx);
                } else if (stroke.points) {
                    if (stroke.userId !== userId) {
                        drawStroke(stroke.points, stroke.color, stroke.size, stroke.opacity, stroke.tool, ctx);
                    }
                }

                strokeCount++;
                document.getElementById('strokeCount').textContent = strokeCount;
                updateBoardCount();
            });

            onValue(strokesRef, (snapshot) => {
                const data = snapshot.val() || {};
                const currentKeys = new Set(Object.keys(data));
                const previousKeys = new Set(Object.keys(allStrokes));

                for (const key of previousKeys) {
                    if (!currentKeys.has(key)) {
                        delete allStrokes[key];
                        redrawCanvas();
                        strokeCount--;
                        document.getElementById('strokeCount').textContent = strokeCount;
                        updateBoardCount();
                    }
                }
            });
        }

        function updateBoardCount() {
            const countElement = document.getElementById(currentBoard + 'Count');
            if (countElement) {
                countElement.textContent = strokeCount;
            }
        }

        window.clearCanvas = function() {
            if (confirm('Clear the entire canvas? This will remove all artwork.')) {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                remove(strokesRef);
                allStrokes = {};
                strokeCount = 0;
                document.getElementById('strokeCount').textContent = strokeCount;
                updateBoardCount();
            }
        }

        window.downloadCanvas = function() {
            const link = document.createElement('a');
            link.download = `canvas-${currentBoard}-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function trackOnlineUsers() {
            const userRef = ref(database, `users/${userId}`);
            const usersRef = ref(database, 'users');
            
            set(userRef, {
                online: true,
                lastSeen: Date.now(),
                username: username,
                color: userColor
            });

            onDisconnect(userRef).remove();

            onValue(usersRef, (snapshot) => {
                const users = snapshot.val();
                const count = users ? Object.keys(users).length : 0;
                document.getElementById('onlineCount').textContent = count + ' online';
            });
        }

        async function init() {
            const isBanned = await checkBan();
            if (isBanned) return;

            initColors();
            initBoards();
            initLayers();
            trackOnlineUsers();
            listenForUpdates();
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            document.getElementById('loading').style.display = 'none';
            document.getElementById('app').style.display = 'flex';
            document.getElementById('chatContainer').style.display = 'flex';
            
            // Send join message
            push(chatRef, {
                system: true,
                message: `${username} joined the canvas`,
                timestamp: Date.now()
            });

            // Show welcome toast
            setTimeout(() => {
                showToast('Welcome!', 'Press Ctrl+K for commands, or B/E/T for tools', 'success');
            }, 1000);
        }

        setTimeout(init, 1000);
    </script>
</body>
</html>
